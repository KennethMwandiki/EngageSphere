# EngageSphere — One-Click Publishing

This repository includes a GitHub Actions pipeline to implement one-click publishing when you push to the `main` branch.

# EngageSphere — One-Click Publishing

This repository includes a GitHub Actions pipeline to implement one-click publishing when you push to the `main` branch.

## What this does

- Builds the web app and deploys to Vercel.
- Builds Android (Gradle) and iOS (Fastlane) and uploads artifacts.
- Publishes artifacts to Google Play when an AAB is present.
- Placeholder guidance for iOS App Store upload (requires macOS runner and real Fastlane lane).
- Publishes artifacts and sends a Slack notification (optional).

## Required repository secrets (GitHub)

Add the following repository secrets in your GitHub repo Settings → Secrets → Actions:

- `VERCEL_TOKEN`, `VERCEL_ORG_ID`, `VERCEL_PROJECT_ID` — for Vercel web deployment
- `GOOGLE_PLAY_SERVICE_ACCOUNT` — JSON for Google Play service account (base64 or JSON string)
- `ANDROID_PACKAGE_NAME` — your Android package name (e.g., com.mycompany.myapp)
- `APPLE_API_KEY` — App Store Connect API key (private key content or reference)
- `APPLE_API_ISSUER_ID` — App Store Connect issuer ID
- `SLACK_WEBHOOK` — (optional) Slack webhook for notifications

Additional secrets for signing and CI:

- `ANDROID_KEYSTORE_BASE64` — base64-encoded Android keystore (.jks). If you prefer, you can store raw keystore but base64 is safer for multiline secrets.
- `ANDROID_KEYSTORE_PASSWORD` — keystore password
- `ANDROID_KEY_ALIAS` — key alias used to sign the APK/AAB
- `ANDROID_KEY_PASSWORD` — key password
- `APP_STORE_CONNECT_API_KEY` — App Store Connect API key (.p8) contents (base64 or raw)
- `APP_STORE_CONNECT_ISSUER_ID` — App Store Connect issuer
- `FASTLANE_PASSWORD` / `FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD` — for Fastlane iOS publishing (if used)

## How to customize

- Replace the `build:android` and `build:ios` scripts in `package.json` with your actual build commands (Gradle, Fastlane, xcodebuild, etc.).
- If your Android project expects signing properties in a different location, adapt the workflow to match (currently writes to `signing.properties`).
- Update the Fastlane `Fastfile` to include a `ci_build` lane that builds and exports an IPA and uploads it to App Store Connect.

## Local testing

You can run the web build locally:

```bash
npm ci
npm run build:web
```

## Fact check — implemented vs to-be-updated

Fully implemented (ready to run once secrets and build config are provided):

- Web build and Vercel deployment (workflow will run `npm run build:web` and call Vercel action).
- Android Gradle build job that runs `./gradlew bundleRelease` and uploads the AAB as an artifact.
- Android keystore decoding and basic wiring — the workflow decodes `ANDROID_KEYSTORE_BASE64` into `android_keystore.jks` and attempts to pass signing properties to Gradle. You must ensure your `app/build.gradle` reads signing properties from the `signing.properties` file or adapt the property names used.
- Artifact collection and conditional publishing: publish job downloads artifacts and will call the Google Play action when an AAB artifact is present.
- iOS Fastlane job skeleton that writes the App Store Connect API key to a file and runs a `fastlane ios ci_build` lane. The workflow uploads any IPA generated by Fastlane as an artifact.

To-be-updated (required from you to fully automate):

- Android signing properties location: ensure your Android Gradle scripts read signing properties from the `signing.properties` file or adapt the Gradle `-P` flags used. If your project uses a different property name or path, update the workflow's build step.
- Fastlane lane name and Fastfile: update your `Fastfile` to include a `ci_build` lane that builds, signs, and exports an IPA using the App Store Connect API key and provisioning profiles (match or manual). Provide `FASTLANE_*` secrets accordingly.
- iOS code signing certificates/profiles: store these securely (Fastlane Match or GitHub Secrets) and configure Fastlane to use them.
- Add release notes, staged rollout controls, and changelog automation (optional but recommended).

## Security

Never commit API keys or certificates into version control. Use the GitHub Secrets feature.

## How to set AI keys (recommended)

1. GitHub Secrets (recommended for CI/production)

	- Go to your GitHub repository → Settings → Secrets and variables → Actions → New repository secret.
	- Add the following secrets (example names used in the code):
	  - `VERTEX_AI_KEY` — your Vertex AI API key / token
	  - `AZURE_OPENAI_KEY` — your Azure OpenAI API key
	  - `GPT5_MINI_KEY` — key for GPT-5 mini (if you use it)

	The CI workflow and production deployment must read these values from environment variables. The backend loads them via `process.env.VERTEX_AI_KEY`, etc.

2. Local development (use `.env` and do NOT commit it)

	- Copy `.env.example` to `.env` and paste your real values into the file on your local machine.

	Example `.env` (local only):

	```env
	VERTEX_AI_KEY=a7cd3859-d497-4c55-9101-5e497a976215
	AZURE_OPENAI_KEY=your-azure-openai-key
	GPT5_MINI_KEY=your-gpt5-mini-key
	```

	- Make sure `.gitignore` contains `.env` (do not commit it).

3. Run the server locally

	```bash
	npm ci
	# ensure .env exists with keys
	node server.js
	```

	On startup the server will warn if any AI keys are missing.
